/*
 * generated by Xtext 2.21.0
 */
package com.shark.lang.tests

import com.google.inject.Inject
import com.shark.lang.DdStandaloneSetup
import com.shark.lang.dd.DataModelFragment
import java.io.ByteArrayInputStream
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.mwe.utils.StandaloneSetup
import org.eclipse.xtext.resource.XtextResource
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

//with a grammar that is EOF sensitive we need to use File Input Stream, as apparently it does not work otherwise...
//hence the use of temp files. Works partially with inMemFile but that fails with eclipse IContainer/IResource based test of 
//constraints in DdValidator. So simple classical temp files and standalone code
@ExtendWith(InjectionExtension)
@InjectWith(DdInjectorProvider)
class DdParsingTest {
	// @Inject ParseHelper<DataModelFragment> parseHelper // To parse text directly but seems failing with EOF dependent grammar
	@Inject ValidationTestHelper validationTestHelper

	// @Inject ResourceHelper resourceHelper;
	// @Inject NodeModelUtils modelUtil //nodeUtil is static...
	// @Inject ITokenDefProvider tokenDefProvider;
	// @Inject Lexer lexer;
	// @Inject Provider<XtextResourceSet> resourceSetProvider
	@Test
	def void testCheckExpressionsPassingCases() {

		val memFile = "testCheckExpressionsPassingCases.dd" -> '''
			''description of this model, why is it structured like that and which entities it contains
			'the first series of constants test nominal declarions of constants for each type which
			'show what is the list of available types
			model Customer_Accounts 
			
			'comments can be put everywhere as a full line but they are related to the next item
			'and they have to follow the indentation strcuture
			'so these first 3 lines will be considered as extra decription of the first costant AVERAGE_AGE below
			'constants have to be upper or it does not compile
			str(7)  DEFAULT_FIRST_NAME= "@NoName" 'each declaration statement is followed by a trailing comment with mandatory description, and string have a max size
			str(6)  DEFAULT_LAST_NAME= "Dupont" 'so here compilation error due to max size too small
			chr  YES = "Y" 'yes constant. A single char string is actually a char in the background
			chr  NO = "N"  'no constant does not compile because it needs to be upper case
			chr CHAR1 = "\u00AF" '!#$%&'()*+,-./:;<=>?@[]^|_`{}~ are accepted as well as \\t \\n \\r \\\\ and \\u+ 4 digits hexacode  
			chr RETURN = "\n" 'no need to escape \
			str(2) DOUBLETAB = "\t\t" ' and that counts the length acordingly so here no error or no warning
			int(2,2)  AVERAGE_AGE = ((3*2)+50) 'to initiate ages of Persons as default, it is an interger of min 1 digit and max 2 digitts so 0 to 100
			int(3,2)  MAX_AGE = (100+20)  'and this fails because literal is too big for the max size of the int. Otherwise expressions can be used anywhere
			date BUG_OF_2000 = "20000101"  'date can be initialized by string and string expressions or with an explicit cast but htis is a bit superfluous 
			date MY_BIRTH = ("1976"&"0409") 'here it fails because the string expression does not have the right length but no format check in expression 										
			stamp CREATION_OF_BANK = "18700101.233000.0000" 'does not compile because the hour is 25
			dec(15,5) MAX_AMOUNT = 3145678190.12345 'max amount does not compile due to too many digits after the comma: a dec 15 5 has max 5 digits on the right
			time MIDNIGHT = "000000" 'to test a time constant 
			stamp MIDNIGHT_STAMP = "20100101.000000.9999" 'to test a time constant 
			chr[2] GENDERS = ("M","F") 'domain values for gender and example of an array declaration. size of array is checked too as compile time
			str(3)[5] ALLOWED_ISO_3_CCY = ("eur","USD","GPB","JPY","RMB") 'domain values for currencies, fails because array is too small 
			bits PLAIN = "001001" 'this is a joke... bits don't support expression just init with a string
			bool TRUE = true 'for testing of boolead, anything but true or false would have a compile error
			date[2] TARGET_HOLIDAYS = ("20000101","20001225") 'bank holidays for europe target2 all put in year 2000, only 2 so warning due to list size
			time[3] CUTOFF_TIMES = ("120000","163000","193059") 'time of sepa cutoffs, does not compile because seconds is 61
			stamp[2] MILLENIUM_BUG = ("20000101.000000.0000","20000101.000000.0000") 'the time after which all should have gone mad
			
			'this is the entity description
			'it can have several lines
			'to decribe the entity person below
			'a Person can be a customer or a related party or an employee 
			Person:
				'extra attribute description for attribute id that follows
				'it can have as many lines as we want, while the trailing comment at the 
				'end of the line is a single line comment. only the trailing is mandatory
				int(10)  id  key 'the internal identifier of the Person
			
				'See here an example of a line continuation \ which is the only way to split a statement into several line
				str(5) name \
										="Chang" 'name of the person which I defaulted to one for the sake of the example
				str(7) prenom = DEFAULT_FIRST_NAME 'first name of the customer
				chr	     gender = GENDERS[0] ' use and array of constant to init the attribute
			
				date     dateOfBirth = BUG_OF_2000 'the date of birth is initialized for generation Millenial 
				time     timeOfBirth = MIDNIGHT 'init at midnight
				str(2)   countryOfBirth_iso2 = "CN" 'initialized to the most common country in the world :-)
			
				str(5)   postalCode = ("9250" & "0") 'here the size of the concat expression is checked and compiles becaus eit is a str 5
				'forbidden physical description data :-)
				bits(5)  physical_description = PLAIN 'blue eyes (0|1) dark hair (0|1) dark skin (0|1) height>1,75 (0|1) fat (0|1)
			
			'a customer can be a person or a company
			Customer:
				int(10) 	id  key 'the internal identifier of the Customer 
				(0..1) isPerson (1..1) Person 'a Cutomer has to be a Person (abstracting the notion of company for the example) but a Person might not be
				(1..n) hasAccounts (0..n) Account 'should move to a 1-n relationship because a customer has at least one account
			
			'banking account, can be of many types (term, savings, current, overdraft...)
			Account: 
				int(11) 			num     key   ! 'the internal acount number 
				dec(13,7) 		balance 'balance os the account with a large enough precision for all type of currency
				str(100) 					description ! 'open description of the account from a customer standpoint, mandatory with !
				date openDate = "20120101" 'opening date of the account
				time openTime = "141853" 'opening time on the client side 
				stamp openTimeStamp = "20120101.141857.1234"  'timestamp at write time on the DB
				bits flags 'to store shit in ity
			
			'default checks done all the time when creating or adding an entity are belo for Account and Person
			'it cannot crossref other entities unless there is a 1-1 relationship
			#Account:
				'test the account opening date validity: it cannot be less than the bank historical creation in 1870 and limite to next 200 years
				test1 (((Account.openDate>=CREATION_OF_BANK) or (Account.openDate<=date("22000101"))) and ((7==8)==true))
				'test date cast
				test2 ((Account.num>=5) or (0<=8) or (Account.openDate==date("20000101")) or ((1+6+Account.balance)>=9))
				'mandatory doc on tests
				test3 (((1+2+4+(5*5*6)+(5/6))==0) or ((10/3) in (1,2)))
				'mandatory doc
				test4 (("" stxt (1,2))=="")  
			
			'default intrinsic checks for a person entity
			#Person:
				'test date on constants
				test1 ((len(Person.name)>=5) or (0<=8) or (Person.dateOfBirth==date("20010102")) or ((1+6+Person.id)<9))
				'test2
				test2 ((1 in (1..4)) and (("ABC" in "DBCDABC")==4))
				'test
				test3 (("A" in "ABCDEF")==0) 
				'test
				test4 (Person.gender in GENDERS)
				'test
				test5 ("hello" in ("hello","bonjour","guten morgen")) 
				'test
				test6 (DEFAULT_FIRST_NAME like str(123))
			
			'All cross checks for persons and accounts
			#Accounts_Person (Person, Account[]):
				'test
				test1 ((len(Person.name)>=5) or (0<=8) or (Person.dateOfBirth==CREATION_OF_BANK) or ((1+6+Account.balance)<9))
				'test
				test2 true
				'test
				test3 ((1+2+3+4+(5*5)+(5*6)+5)==6)
			
			
		'''

		val errList = testFileWithErrors(memFile)
		Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
	}

	@Test
	def void testMinus() {

		val memFile = "testMinus.dd" -> '''
			'this is a test model   
			model Minus_Test
			int(1) TEST = -(1) 'to debug an error on minus
			int(3,2) TEST2 = 1000 'fails
			int(3,2) TEST3 = 1 'fails
			int(3,2) TEST4 = 10 'works
			int(4,2) MAX = -(((100+20)*1)) 'this one should work
			int(3,2) MAX2 = -(((100+20)*1)) 'this one should fail
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message ==
			"Expression length is incompatible with the declaration length, it is 4 and not 3"),
			"Length calculation inside a unary operator does not work")
		Assertions.assertTrue((errList.get(2).message ==
			"Expression min size is incompatible with the declaration min size, it is 1 and not 2"),
			"Length calculation inside a unary operator does not work")
		Assertions.assertTrue((errList.get(4).message ==
			"Expression length is incompatible with the declaration length, it is 4 and not 3"),
			"Length calculation inside a unary operator does not work")
		Assertions.assertTrue(errList.size == 5, "New Errors or Warning are listed, to be checked")
	}

	@Test
	def void testAttributeInConstant() {

		val memFile = "testAttrInCst.dd" -> '''
			'this is a test model   
			model AttributeInCst_Test
			int(1) TEST1 = Account.num 'fails because does not make sense
			dec(1,2) TEST2 = ((1-(Account.num +1)+4)/10) 'fails too same reason
			
			'banking account, can be of many types (term, savings, current, overdraft...)
			Account: 
				int(1) 			num     key   ! 'the internal acount number 
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message == "A constant cannot be initiated with an attribute or attribute based expression"),
			"Check on attribute used in constant definition failed")
		Assertions.assertTrue((errList.get(1).message == "A constant cannot be initiated with an attribute or attribute based expression"),
			"Check on attribute used in constant definition failed")
		Assertions.assertTrue(errList.size == 2, "New Errors or Warning are listed, to be checked")
	}

	// test a bug fix on precision propagation between constants
	@Test
	def void testIntegerFromConstant() {

		val memFile = "testIntFromCst.dd" -> '''
			'this is a test model   
			model AttributeInCst_Test
			int(2,2) TEST1 = 10 'fails because does not make sense
			int(2,2) TEST2 = TEST1 'fails too same reason
			
		'''

		val errList = testFileWithErrors(memFile)
		Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')

	}

	@Test
	def void testArray() {

		val memFile = "testArray.dd" -> '''
			'this is a test model   
			model Array_Test
			chr[2] GENDERS = ("M","F") 'domain values for gender 
			str(3)[5] ALLOWED_ISO_3_CCY = ("eur","USD","GPB","JPY","RMB") 'domain values for currencies
			str(3)    DEFAULT_ISO_3_CCY = "eur" 'default is euro
						
			'this is a person
			Person:
				chr	gender1 = GENDERS[0] ' use and array of constant to init the attribute
				chr	gender2 = GENDERS[2] ' out of bound error
				str(3)	ccy = ALLOWED_ISO_3_CCY ' error as it requires an index to access an array
				str(3)	ccy2 = DEFAULT_ISO_3_CCY[0] 'error as it is not an array
				int(2)	length = len(ALLOWED_ISO_3_CCY) 'len and in and stxt on array/lists are the 3 only operations allowed
				str(6)	two_ccy = (DEFAULT_ISO_3_CCY & ALLOWED_ISO_3_CCY[0]) 'ok
				str(6)	two_ccy2 = (DEFAULT_ISO_3_CCY & ALLOWED_ISO_3_CCY) 'expression not allowed on array
								
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message == "Index is out of bound"), "Out of bound Check With Array Not Working")
		Assertions.assertTrue((errList.get(1).message == "non array cannot use a list or range as default/init value"),
			"non array variable init using array check Not Working")
		Assertions.assertTrue((errList.get(2).message == "This constant is not an array and so no index can be specified to access it"),
			"index on non array check not working")
		Assertions.assertTrue((errList.get(4).message == "Invalid Operator: only in and stxt operator can be used on a list, here it is &"),
			"Array not allowed in expression check not working")
		Assertions.assertTrue(errList.size == 6, "New Errors or Warning are listed, to be checked")

	}

	@Test
	def void testRound() {

		val memFile = "testRound.dd" -> '''
			'this is a test model   
			model Round_Test
			dec ( 3 , 1 ) TEST1 = ( ( 2.23 + 1 ) round 1 ) 'comment
			dec ( 3 , 1 ) TEST2 = ( ( 2.2 + 1.7896 ) round 2 ) 'comment
			dec ( 3 , 1 ) TEST3 = ( 2.234 + 1.6745 ) 'comment
			str ( 3 , 1 ) TEST4 = (2.23 round 2) 'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message ==
			"Expression precision is incompatible with the declaration precision, it is 2 and not 1"),
			"Precision Validation Check With Round Not Working")
		Assertions.assertTrue((errList.get(1).message ==
			"Expression precision is incompatible with the declaration precision, it is 4 and not 1"),
			"Precision Validation Check Without Round Not Working")
		Assertions.assertTrue((errList.get(2).message == "Invalid initialization: expression type mismatch with attribute or constant"),
			"Type Checking Not Working On Round: Should Detect That Round Is a Num And Not A Str")
		Assertions.assertTrue(errList.size == 5, "New Errors or Warning are listed, to be checked")
	}

	@Test
	def void testStxt() {

		val memFile = "testStxt.dd" -> '''
			'this is a test model   
			model Round_Test
			str ( 3 , 1 ) TEST1 = ( "AB" & "AB" )	'comment
			str ( 3 , 1 ) TEST2 = (( "AB" & "AB" ) stxt (1,3) )'comment
			str ( 4 )     TEST3 = ("A" & "A" & "A" & "A" & "A") 'comment
			str (4,2)     TEST4 = "A" 'comment
			str ( 3 , 1 ) TEST5 = ("ABC" stxt (1,3,4) )'comment
			str ( 3 ) TEST6 = (1 stxt (1,3) )'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		// warnings are skipped in the list
		Assertions.assertTrue((errList.get(0).message ==
			"Expression length is incompatible with the declaration length, it is 4 and not 3"),
			"Length Validation Check Not Working on binary cat")
		Assertions.assertTrue((errList.get(1).message ==
			"Expression length is incompatible with the declaration length, it is 5 and not 4"),
			"Length Validation Check Not Working on multiple cat")
		Assertions.assertTrue((errList.get(3).message ==
			"Expression min size is incompatible with the declaration min size, it is 1 and not 2"),
			"Min length validation on string not working")
		Assertions.assertTrue((errList.get(4).message ==
			"Type Mismatch: substring operator requires string on the left and integer list on the right"),
			"Operator validation not working")
		Assertions.assertTrue((errList.get(5).message ==
			"Type Mismatch: substring operator requires string on the left and integer list on the right"),
			"Type Mismatch validation on stxt operator is not working")
		Assertions.assertTrue((errList.get(6).message == "Invalid initialization: expression type mismatch with attribute or constant"),
			"Type Mismatch validation is not working")
		Assertions.assertTrue(errList.size == 8, "New Errors or Warning are listed, to be checked")

	}

	@Test
	def void testMultType() {

		val memFile = "testStxt.dd" -> '''
			'this is a test model   
			model Round_Test
			int ( 3,2 )     TEST1 = (323+4+"" ) 'comment
			int ( 3,2 )     TEST2 = (32*4*"" ) 'comment
			str ( 3,2 )     TEST3 = ("A" & "A" & 1.2) 'comment
			bool			    TEST4 = (true or false or "") 'comment
			bool			    TEST5 = (true and false and "") 'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message == "Type Mismatch: all the members of the addition should be of numeric type"),
			"Type validation of Multiple add fails")
		Assertions.assertTrue((errList.get(1).message == "Type Mismatch: all the members of the multiplication should be of numeric type"),
			"Type validation of Multiple mult fails")
		Assertions.assertTrue((errList.get(2).message ==
			"Type Mismatch: all the members of the concat expression should be of string type"), "Type validation of Multiple cat fails")
		Assertions.assertTrue((errList.get(3).message ==
			"Type Mismatch: all the members of the logical Or expression should be of boolean type"),
			"Type validation of Multiple or fails")
		Assertions.assertTrue((errList.get(4).message ==
			"Type Mismatch: all the members of the logical And expression should be of boolean type"),
			"Type validation of Multiple and fails")
		Assertions.assertTrue(errList.size == 5, "New Errors or Warning are listed, to be checked")

	}

	@Test
	def void testLike() {

		val memFile = "testLike.dd" -> '''
			'this is a test model   
			model Round_Test
			bool			    TEST1 = ("TOTO" like "TO") 'comment
			bool			    TEST2 = ("TATA" like "") 'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message == "Invalid Operand: String template for a like operator cannot be empty"),
			"Verification of right operand of like operator fails")
		Assertions.assertTrue(errList.size == 1, "New Errors or Warning are listed, to be checked")
	}

	@Test
	def void testDateCasts() {

		val memFile = "testDateCast.dd" -> '''
			'this is a test model   
			model Round_Test
			date			    TEST1 = date("ABC") 'comment
			stamp			    TEST2 = stamp("CDE") 'comment
			time            TEST3 = time("EFG") 'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message == "Invalid Date Format: it should be YYYYMMDD"),
			"Verification of date cast literal operand format failed")
		Assertions.assertTrue((errList.get(1).message == "Invalid Timestamp Format: it should be YYYYMMDD.HHMMSS.ssss"),
			"Verification of stamp cast literal operand format failed")
		Assertions.assertTrue((errList.get(2).message == "Invalid Time Format: it should be HHMNSS"),
			"Verification of time cast literal operand format failed")
		Assertions.assertTrue(errList.size == 3, "New Errors or Warning are listed, to be checked")
	}

	@Test
	def void testChrLexing() {

		val memFile = "testChrlex.dd" -> '''
			'this is a test model   
			model Round_Test
			chr CHAR1 = "\n" 'comment
			chr CHAR2 = "\u00AF" 'comment
			chr CHAR3 = "\u00AF&" 'comment
			str(4) STR1 = "\t\t\t\n" 'comment
			str(4) STR2 = "\t\t\t\u0101A9" 'comment
			
		'''

		val errList = testFileWithErrors(memFile)
		// Assertions.assertTrue(errList.isEmpty, '''Errors: «errList.join("\n ")»''')
		Assertions.assertTrue((errList.get(0).message ==
			"Expression length is incompatible with the declaration length, it is 2 and not 1"), "Lexing of char failed on escapes")
		Assertions.assertTrue((errList.get(1).message ==
			"Expression length is incompatible with the declaration length, it is 6 and not 4"), "Lexing of string failed on escapes")
		Assertions.assertTrue(errList.size == 2, "New Errors or Warning are listed, to be checked")
	}

	def testFileWithErrors(Pair<String, String> fileDesc) {
		//val tempFile = Files.createTempFile("xtext-unit-test-", fileDesc.key);
		//tempFile.toFile.deleteOnExit;

		// write in file
		//Files.write(tempFile, fileDesc.value.getBytes(StandardCharsets.UTF_8));

		// old version with inMemFile
		/*val resourceSet = resourceSetProvider.get
		 * resourceSet.URIConverter.URIHandlers.add(0, handler)
		 * val resource = resourceSet.getResource(URI.createURI(fileDesc.key), true)
		 resource.load(null)*/
		new StandaloneSetup().setPlatformUri("../");
		val injector = new DdStandaloneSetup().createInjectorAndDoEMFRegistration();
		val resourceSet = injector.getInstance(XtextResourceSet);
		resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);
		val resource = resourceSet.createResource(URI.createURI("test:/"+fileDesc.key));
		val in = new ByteArrayInputStream(fileDesc.value.getBytes());
		resource.load(in, resourceSet.getLoadOptions());
		val model = resource.contents.head as DataModelFragment
		validationTestHelper.validate(model)

	}

}
