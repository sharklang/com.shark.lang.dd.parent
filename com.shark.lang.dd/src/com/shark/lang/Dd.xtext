grammar com.shark.lang.Dd hidden(WS, CONT, IDENT)

generate dd "http://www.sharklang.org/lang/Dd"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

//no empty entity and so mandatory BEGIN/END structure
//BEGIN / END added when there is an indent level change
//EOL tokens are added after an indent constant or no indent and a new line
//IDENT triggered after a Comment so generates EOL 
//with such grammar, comment are controlled for metrics and positioning --> not free anywhere --> there and concise
//TODO document the dd language itself better in the example and doc: about the use of expressions, size and precisions can be analysed recursively everywhere... 
//TODO bug on -(1) invalid expression type?
//TODO bug init integer from constant
//TODO bug constant can be init from attribute
//TODO add the check that cross ref can be done only if this is a 1-1 relationship: 2 attribute belong to 2 different entity with 1-1 only
//TODO test expressions interactively and build non passing JUNIT tests using excel random
//TODO update formatter
//TODO customize error messages for parser and lexer: eg constant en maj
//TODO use long for INT and DEC size verification instead of int
//TODO do a first output: flatbuffer et 
//TODO see other todos
//TODO use case of the unset value
//TODO test date operations + 1*DAY... basing on the generator error management
//TODO add min, max, avg
//TODO semantic highlighting example
//TODO add content assist
//TODO move up error message as constants and add more automatic unit tests
//TODO move checkOpertor to helper class
//TODO split into reusable grammar and create sd and sk languages
//TODO in this context consider removing int and stick to general dec(n,0)?
//TODO Improve calculateExpression and add it to the main descent of getExpressionType using a value extra member so that at least int(2,2)=90+20 fails
//TODO check and neutralize useless comment associator
//TODO check that all text is assigned
//TODO cleanup error messages in properties
//ecore sample editor. editor read again the XtextRessource so normal that my boolean are not there. they would have to 
//be persisted in hidden text... But core code generation maybe the in memory AST is the same as in validation
//to test.
DataModelFragment returns DataModelFragment:
	(modelDesc+=LineComment)+
	'model' name=OBJID EOL
	(constants+=Constant)*
	(entities+=Entity)*
	(constraints+=Constraint)*;

	/////////////////////////
//Statement 0: constants
Constant returns Constant:
	(extraAttrDesc+=LineComment)*
	dataType=DataType
	(attributeSize=AttributeSize)?
	(arraySize=ArraySize)?
	name=CSTID
	('=' defaultValue=SharkExpression)
	(attrDesc=TrailComment)
	EOL;

	//////////////////////////////////////////
//First Block of statements: entity block
Entity returns Entity:
	(entityDescLines+=LineComment)+
	name=OBJID ('->' extends=[Entity])? ':'
	BEGIN
	(attributes+=Attribute)+
	(relationships+=Relationship)*
	END;

	////////////Statement 1: Attributes

//all is initialized and we'll see if that creates perf issue.
//the unset value constant is either zero or Min and "". it can be overridden in ddt
Attribute returns Attribute:
	(extraAttrDesc+=LineComment)*
	dataType=DataType (attributeSize=AttributeSize)? 
	(arraySize=ArraySize)?
	name=ID
	('=' defaultValue=SharkExpression)?
	(primaryKey?='key')?
	(mandatory?='!')?
	(attrDesc=TrailComment) //mandatory description of the Attribute
	//	(nullable?='!null')? 
	EOL;

//valid for all types except date time and bool. for int, str and char it can be min max, for dec precision is mandatory
AttributeSize returns AttributeSize:
	('(' length=INT (',' precision=INT)? ')');
	
//not only for constants in this dd context, but also attribute. TODO check cassandra and flatbuuffer impact
ArraySize returns ArraySize:
	'[' size=INT ']'
;

	////////////Statement 2: Relationships
Relationship returns Relationship:
	cardi1=RangeExpression name=ID cardi2=RangeExpression linkTo=[Entity|OBJID]
	(relDesc=TrailComment) //mandatory description of the Attribute
	EOL;

	///////////////////////////////////////////////
//Second Block of statements: check constraints
Constraint returns Constraint:
	(chkDescLines+=LineComment)+
	name=CHKID ':'
	BEGIN
	(check+=CheckExpression)+
	END;

	////////////Statement 1: checks. If same name as entity they are intrinsic and executed systematically
//at each creation time of the object. The other need to be invoked: check myCust#Customer_Account_Crosschecks.all or .<id>
//because a full context with all objects is required and also a relationship is required to get the related objects
//crosschecks only work when called from the root object and descending the tree. Validation would be applied to all 
//children automatically
CheckExpression returns CheckExpression:
	(chkDesc+=LineComment)+
	name=ID expr=SharkExpression EOL;

	///////////////////////////////////////////////
//reusable rules (expression, datatype rules...)
//below expression are very badly written but easy to understand
//Start was done with only Binary expressions with brackets and list expressions were added to avoid putting
//brackets everywhere. This still limits what is allowed to be written but makes it a style that is quite readable
//avoiding priority and errors of operators
//Note; syntactic predicate below works only if written in order of priority
//operation on datetime var: all is done on a time stamp and rounded/cut to keep only the interesting
//part like only the hours or the date... hence all date compatible
SharkExpression returns SharkExpression:
	=> RangeExpression |
	=> AddExpression | => MultExpression |
	=> AndExpression | => OrExpression |
	=> CatExpression | => ListExpression | 
	BinaryExpression | UnaryExpression |
	TerminalExpression | IdentifierExpression
	;

BinaryExpression returns BinaryExpression:
	'(' left=SharkExpression op=BinaryOperator right=SharkExpression ')' 
	 (value=NUL precision=INT length=INT)? //starting the sequence with NULL ensures it will never parse anything
	;

UnaryExpression returns UnaryExpression:
	op=UnaryOperator '(' left=SharkExpression ')'
	 (value=NUL precision=INT length=INT)?
	;

AddExpression returns AddExpression:
	'(' left=SharkExpression op=('+' | '-') right=SharkExpression (addElts+=AddExpressionElt)+ ')'
	 (value=NUL precision=INT length=INT)?
	;

AddExpressionElt returns AddExpressionElt:
	op=('+') right=SharkExpression;

MultExpression returns MultExpression:
	'(' left=SharkExpression op=('*') right=SharkExpression (multElts+=MultExpressionElt)+ ')'
	 (value=NUL precision=INT length=INT)?
	;

MultExpressionElt returns MultExpressionElt:
	op=('*') right=SharkExpression;

AndExpression returns AndExpression:
	'(' left=SharkExpression op=('and') right=SharkExpression (andElts+=AndExpressionElt)+ ')'
	;

AndExpressionElt returns AndExpressionElt:
	op=('and') right=SharkExpression;

OrExpression returns OrExpression:
	'(' left=SharkExpression op=('or') right=SharkExpression (orElts+=OrExpressionElt)+ ')'
	;

OrExpressionElt returns OrExpressionElt:
	op=('or') right=SharkExpression;

CatExpression returns CatExpression:
	'(' left=SharkExpression op=('&') right=SharkExpression (catElts+=CatExpressionElt)+ ')'
	 (value=NUL length=INT)?
	;

CatExpressionElt returns CatExpressionElt:
	op=('&') right=SharkExpression;
	
ListExpression returns ListExpression:
	op='(' left=SharkExpression (ListElts+=ListExpressionElt)+ ')' 
	;

ListExpressionElt returns ListExpressionElt:
	op=(',') right=SharkExpression;
	
RangeExpression returns ListExpression:
	{ListExpression} '(' range=RANGE ')' |
	{ListExpression} => '(' range=RANGEINF ')'
;

enum BinaryOperator:
	opOr='or' | opAnd='and' | opAdd='+' | opMin='-' | opMult='*' | opDiv='/'
	| opMod='%' | opEq='==' | opGt='>' | opLt='<' | opLte='<=' | opGte='>=' | opPow='^'
	| opLike='like' | opDif='!=' | opCat='&'	| opIn='in' | opStxt='stxt' | opRound='round' 
;

enum UnaryOperator:
	opNot='not' | opNeg='-' | strCast='str' | intCast='int' | decCast='dec' | dateCast='date' |
	timeCast='time' | opLen='len' | stampCast='stamp';

TerminalExpression returns TerminalExpression:
	({StrValue} value=STR |
	{IntValue} value=INT |
	{DecValue} value=DEC |
	{ChrValue} value=CHR |
	{CstValue} value=[Constant|CSTID] (index=ArraySize)?|
	{BoolValue} value=Boolean |
	{UnsetValue} value=Unset);

IdentifierExpression returns TerminalExpression:
	{IdentifierExpression} value=[Attribute|QualifiedName] (index=ArraySize)?;

QualifiedName:
	(OBJID '.')? ID;

LineComment:
	{Comment} line=CMT EOL;

TrailComment:
	{Comment} line=CMT;

enum Unset:
	unset='unset';

enum Boolean:
	trueCst='true' |
	falseCst='false';

	//the unset value is used to process/validate types in validator but should not (cannot?) be typed in editor
enum DataType returns DataType:
	str='str' | dec='dec' | date='date' | time='time' | chr='chr' | int='int' | stamp='stamp' | bits='bits' | bool='bool'
	|
	unset='\uFFA0\uFFA0\uFFA0';
	//unset here allows to use the value in the validation logic but it will never be created by lexer

	/////////////////////////////////////////////////////////
//TERMINALS: TODO export in a re-usable sharkdsl grammar

//The following synthetic tokens are used for the indentation-aware blocks
//they are declared here and injected in the lexer in DDTokenSource Class
//to create from indentation position block begin and end token as well as statement end EOL token
terminal BEGIN:
	'synthetic:BEGIN'; // increase indentation
terminal END:
	'synthetic:END'; // decrease indentation
terminal EOL:
	'synthetic:EOL'; // allow to have a classical set of parser rule with end statement token like ; but not typed
terminal NUL:
	'synthetic:NUL'; // to create tokens that are never parsed but used in the processing and validation logic



//reused below
terminal fragment HEX:
	('0'..'9' | 'A'..'F' | 'a'..'f');

terminal fragment NUM:
	('0'..'9')+;

terminal fragment UNI:
	'u' HEX HEX HEX HEX;

terminal fragment ESC:
	'\\' ('t' | 'n' | 'r' | '"' | '\\' | UNI);

terminal fragment ASCII:
	('!' | '#' | '$' | '%' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0'..'9' | ' ' | ':' | ';' | '<'
	| '=' | '>' | '?' | '@' | 'A'..'Z' | '[' | ']' | '^' | '_' | '`' | 'a'..'z' | '{' | '|' | '}' | '~');

terminal fragment NL:
	('\r'? '\n');

//beware terminals are consumed in this order of precedence
//and lexer eats the longest possibility. caret removed
//string literals don't allow all escapes only common ones, and only double quotes
//and still need to put Unicode support for special char so \u is in
//with string compaction, non ASCII char is not encouraged in code/literals --> Unicode only
terminal STR returns ecore::EString:
	'"' (ESC | ASCII) (ESC | ASCII) (ESC | ASCII)* '"';

terminal CHR returns ecore::EString: //simpler to manage a string and remove quotes rather than using a value converter
//TODO consider using a value converter
	'"' (ESC | ASCII)? '"';

terminal RANGEINF returns ecore::EString:
	NUM '..n'
;

terminal RANGE returns ecore::EString:
	NUM '..' NUM
;

terminal CHKID returns ecore::EString:
	'#' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal CSTID returns ecore::EString:
	('A'..'Z') (('A'..'Z') | '_' | '0'..'9')*;

terminal OBJID returns ecore::EString:
	('A'..'Z') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

	//for members and local variables and functions
terminal ID returns ecore::EString:
	('a'..'z' | '_' | '~') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

	//although xtext doc advises datatype rule. kept like that if it fails will be educational, TBC
terminal DEC returns ecore::EBigDecimal:
	NUM '.' NUM;

terminal INT returns ecore::EInt:
	NUM;

terminal CONT returns ecore::EString:
	'\\' NL+;

	//convention with xtext and the WS terminal for indentation. I separate from blanks
terminal IDENT returns ecore::EString:
	(NL)+ ('\t')*;

terminal CMT returns ecore::EString:
	"'" !('\r' | '\n')*;

terminal WS returns ecore::EString:
	(' ' | '\t')+;

terminal ANY_OTHER returns ecore::EChar:
	.;