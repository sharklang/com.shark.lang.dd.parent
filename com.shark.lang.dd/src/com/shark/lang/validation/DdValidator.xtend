/*
 * generated by Xtext 2.21.0
 */
package com.shark.lang.validation

import com.google.inject.Inject
import com.google.inject.Provider
import com.shark.lang.dd.ArraySize
import com.shark.lang.dd.CheckExpression
import com.shark.lang.dd.Constraint
import com.shark.lang.dd.CstValue
import com.shark.lang.dd.DdPackage
import com.shark.lang.dd.Entity
import com.shark.lang.dd.IdentifierExpression
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ComposedChecks

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * It contains the following validation:
 * 	TODO test the global scope with several project and dependencies
 * 	- checks that entities are unique in the global scope 
 * 	- checks that the intrinsic check constrains group only refers attribute of the related entity
 * 	- checks that the check constraints are bool
 * 
 */
@ComposedChecks(validators=#[DdDeclarationValidator])
//TODO check numberUtil iCreatable and compare to exception management below 
class DdValidator extends AbstractDdValidator {

	@Inject
	IContainer.Manager containerManager;
	@Inject
	IResourceDescriptions resourceDescriptions
	@Inject
	Provider<XtextResourceSet> resourceSetProvider;

	@Check
	def checkEntityGloballyUnique(Entity entity) {
		// visible containers is part of the global scope provider system
		val entity_description = resourceDescriptions.getResourceDescription(entity.eResource.URI)
		val visibleContainers = containerManager.getVisibleContainers(entity_description, resourceDescriptions)
		for (visibleContainer : visibleContainers) {
			for (_entity_description : visibleContainer.getExportedObjectsByType(DdPackage.Literals.ENTITY)) {
				val _entity = resourceSetProvider.get.getEObject(_entity_description.EObjectURI, true) as Entity
				if((entity.eResource.URI != _entity.eResource.URI) && (entity.name == _entity.name)) {
					error('Entity duplication', entity, DdPackage.Literals.ENTITY__NAME)
				}
			}
		}
	}

	// check that when the contraint name has the same with # as an entity of same file, then it manages only the entity attributes or constants and literals
	// indeed these expressions will be checked at each time the object is created/changed
	@Check
	def checkAttributesInEntityConstraint(Constraint cstr) {
		val cstr_description = resourceDescriptions.getResourceDescription(cstr.eResource.URI)
		val container = containerManager.getContainer(cstr_description, resourceDescriptions)

		val cstrName = cstr.name.substring(1, cstr.name.length) // strip out # from constraint name
		// get list of all entities in this file and check each if name is same
		for (_entity_description : container.getExportedObjectsByType(DdPackage.Literals.ENTITY)) {
			val _entity = resourceSetProvider.get.getEObject(_entity_description.EObjectURI, true) as Entity
			if(cstrName == _entity.name) {
				// in that case we check the list of operands to verify that none goes outside of the entity scope
				for (CheckExpression chk : cstr.check.toList) {
					for (EObject eObj : chk.eAllContents.toIterable) {
						if(eObj instanceof IdentifierExpression) {
							val ident = eObj as IdentifierExpression
							val referredEntity = ident.value.eContainer as Entity
							if(referredEntity.name != cstrName) {
								error(
									"Invalid Entity check expression: it cannot use a reference to an attribute outside of the referred Entity here " +
										referredEntity.name + " is used, but allowed only are attributes from " + cstrName, ident,
									DdPackage.Literals.IDENTIFIER_EXPRESSION__VALUE)
							}
						}
					}
				}
			}
		}
	}

	// check that index of the identifier is in line with the array size declared
	@Check
	def checkArrayConsistency(ArraySize arraySize) {
		val parent = arraySize.eContainer
		if(parent instanceof IdentifierExpression) {
			val idExpr = parent as IdentifierExpression
			val attr = idExpr.value
			if(attr.arraySize === null) {
				error("This attribute is not an array and so no index can be specified to access it", arraySize,
					DdPackage.Literals.ARRAY_SIZE__SIZE)
			} else if(arraySize.size >= attr.arraySize.size) {
				// array access is index from 0 to size-1
				error("Index is out of bound", arraySize, DdPackage.Literals.ARRAY_SIZE__SIZE)
			}
		} else if(parent instanceof CstValue) {
			val idExpr = parent as CstValue
			val cst = idExpr.value
			if(cst.arraySize === null) {
				error("This constant is not an array and so no index can be specified to access it", arraySize,
					DdPackage.Literals.ARRAY_SIZE__SIZE)
			} else if(arraySize.size >= cst.arraySize.size) {
				// array access is index from 0 to size-1
				error("Index is out of bound", arraySize, DdPackage.Literals.ARRAY_SIZE__SIZE)
			}
		}
	}
} //end class
